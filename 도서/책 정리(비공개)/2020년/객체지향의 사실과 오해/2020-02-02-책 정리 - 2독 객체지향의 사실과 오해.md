## 목차
- 협력하는 객체들의 공동체

## 1. 협력하는 객체들의 공동체

### 키워드 정의
- 역할 : 객체가 수행하는 책임의 집합
- 책임 : 객체에게 온 메세지 또는 그 메세지에 응답하는 것.
- 자율성 : 객체 스스로 프로퍼티를 관리하고 외부와는 정해진 메세지로만 소통하는 것. 외부에선 객체가 무엇(what)을 하는 지는 알 수 있지만 어떻게(how)하는 지는 알 수 없다.
- 메세지 : 외부에서 객체에게 온 요청
- 메서드 : 객체가 요청받은 메세지를 수행하는 방법

### 챕터 정리
이 챕터는 객체지향, 객체, 역할, 책임, 협력의 개념에 대해 설명한다. 저자는 객체 지향은 실세계를 모방하는 것이 아니라 오히려 새로운 세계를 창조하는 것이라 말한다. 이 책을 관통하는 기본적인 전제이다. 우리는 객체지향을 이해하기 위해서 실세계를 통해 비유로 이해하려 하지만 100% 객체 지향을 표현할 수 없다. 왜냐하면 실세계의 객체와 소프트웨어의 객체는 큰 차이가 있다. 바로 자율성이 있느냐 없느냐의 차이이다. 소프트웨어의 객체는 자율성을 가지고 스스로 판단한다.<br>
역할은 책임을 내포한다. 하나의 역할엔 다양한 책임이 있을 수 있다. 책임을 수행하는 방법은 객체가 자율적으로 정한다. 요청에 응답하는 건 외부에 보이지만 내부에선 자기 만의 방식이 있는 것. 이는 다형성과도 연결된다.<br>
객체 지향에서 강조하는 객체의 특성은 자율성이다. 자율성은 내부와 외부를 명확히 구분할 때 구현된다. 내부와 외부로 구분한다는 의미는 객체의 프로퍼티는 private 제어자로 내부에 한정한다. 만약 외부에서 프로퍼티를 가져올 일이 있으면 getter를 통해 가져올 수 있다.<br>
메세지는 객체에게 온 요청이다. 메서드는 객체가 들어온 메세지를 수행하는 방법을 의미한다. 메서드란 의미 자체가 방법을 뜻하는 데 이제 왜 메서드인지 알 수 있다.

## 2. 이상한 나라의 객체

### 키워드 정의

- 상태 : 객체의 행동에 따라 변하는 값. 상태를 통해서 객체의 상황을 쉽게 이해할 수 있다.
- 행동 : 객체의 상태를 변화시키는 움직임. 행동의 결과는 상태를 통해서 파악 가능하다.
- 식별자 : 객체의 고유한 프로퍼티
- 캡슐화 : 객체가 자신의 상태를 외부에 노출하지 않는 것. 객체의 상태는 객체 스스로 변화시킬 수 있기 때문이다.
- 부수효과 : 객체 자신의 행동으로 상태가 변하는 것
- 책임주도 설계 : 협력을 위한 메세지를 정의하고 그 메세지를 수행할 객체를 정하는 방식. 포인트는 객체 간의 메세지를 먼저 정한다는 점. 그 다음 책임을 객체에게 부여한다.
- 추상화 : 내 기준으로 어떤 사물의 중요한 부분만 남기고 불필요한 부분은 제거하는 기법. 핵심만 남긴다.

### 챕터 정리
이 챕터는 상태, 행동, 식별자, 프로그램의 객체는 현실의 모방이 아니라 창조라는 것을 설명한다. 객체란 사람이 분명히 인지하고 식별할 수 있는 물리적, 개념적 경계를 의미한다. 자동차, 액자, 노트북, 부모님 등 객체가 될 수 있다. 또한 객체는 상태와 행동과 식별자를 가진 존재이다. 여기서 식별자란 객체의 고유의 상태를 말한다.<br>
우리는 똑같이 생긴 소나타 차를 보더라도 같은 차라고 하지 않는다. 각각의 자동차는 식별자가 있기 때문이다. 하지만 숫자, 문자열, 참과 거짓을 객체로 보진 않는다. 종이에 숫자 1과 1이 적혀있으면 같은 1로 바라볼 뿐이다.<br>
저자는 말한다. 프로그램 객체는 현실 세계의 모방이 아니라 은유이다. 은유라는 의미는 프로그램 객체와 현실 객체는 완전히 다른 존재이다. 하지만 프로그램 객체를 사람들에게 이해하기 쉽게 표현하기 위해 현실 객체의 이름을 가져온다. 이것은 이 둘의 표현적 차이(representational gap)을 줄일 수 있다.

## 3. 타입과 추상화

### 키워드 정의
- 개념 : 객체 간의 공통점을 뽑아내 객체를 분류하는 틀
- 분류 : 개념을 객체에게 적용하는 것
- 인스턴스 : 한 객체가 어떤 개념안에 포함되서 들어오면 그 객체를 부르는 것
- 타입 : 프로그래밍에서 부르는 개념과 같은 의미
- 데이터 타입 분류 : 모든 데이터는 원래 0과 1로 이루어져 있기 때문에 이를 분류하기 위해 각 특성에 맞게 분류함.
- 다형성 : 하나의 메세지로 서로 다른 방식으로 응답하는 능력

## 4. 역할, 책임, 협력

### 키워드 정리
- 책임 : 객체에게 주어진 요청에 응답하는 것
- 메세지 전송 : 하나의 객체가 다른 객체에게 협력을 요청하는 것
- 책임-주도 설계 : 먼저 객체 간 책임(메세지)를 정한 다음 그 책임을 수행할 객체를 정하는 방식
- 디자인 패턴 : 다양한 책임-주도 설계의 결과이다. 여러가지 상황에 적용할 수 있는 책임-주도 설계 방식들
- TDD : 테스트 주도 개발방식으로 결과를 예측한 테스트 코드를 만들고 그 테스트를 통과하기 위한 코드를 작성하는 방식. 테스트를 통과하는 코드를 작성하면서 객체 간의 역할과 책임을 설계한다.

## 5. 책임과 메세지

### 키워드 정리
- 객체에게 자율권을 주는 것은 너무 상세한 책임(메세지)가 아니라 포괄적인 책임이다. ex) 증언하라 vs 어제 본 것을 글로 증언하라
- What/Who 사이클 : 협력(어플리케이션)을 위해 무엇을 해야하는 지 정한 뒤 그걸 누가 할지 정하는 설계 방식, 책임-주도 설계와 맞물린다.
- Tell & Don't ask 법칙 : 우선 메세지를 보내라, 누군지 묻지 말고!. What/Who 사이클과 비슷하다. 메세지를 정의하고 객체를 정해라. 누가 하든 그 책임을 수행하면 누구든 가능하다.
- 인터페이스 : 서로 다른 객체의 경계에서 둘이 상호 작용할 수 있게 도와주는 장치
- 구현 : 객체의 내부 구조 및 행동(메서드)를 의미한다.
- 인터페이스와 구현 분리 원칙 : 외부와 소통하는 객체의 책임은 노출하되 구현은 내부로 감추는 행위를 말한다. 객체의 자율성을 강조한다.
- 캡슐화 : 외부와 소통하는 인터페이스는 노출하되 객체의 구현은 내부로 감추는 것.

## 6. 객체 지도

### 키워드 정리
- 기능 설계 : 제품이 사용자를 위해 무엇을 할 수 있는지에 대한 초점
- 구조 설계 : 제품의 형태가 어떠해야 하는지에 대한 초점
- 멘탈 모델 : 사람들이 자신과 상호작용하는 영역에 대해 가지고 있는 생각의 구조
- 도메인 모델 : 도메인에 있는 개념과 개념 사이의 관계를 표현한 것
- 표현적차이, 의미적 차이 : 소프트웨어 객체와 현실 객체의 의미적 거리
- 유스케이스 : 사용자와 어플리케이션이 상호 작용하는 과정을 표현한 것
- 연결완전성 : 도메인을 모델링하는 기법과 도메인을 프로그래밍하는 기법이 동일한 것. (도메인 -> 코드)
- 가역성(reversibility) : 코드의 변경을 통해 도메인의 변경 사항을 유추할 수 있는 것 (코드 -> 도메인)

## 7. 함께 모으기

### 키워드 정리
- 마킨 파울러의 객체 지향 설계 3가지 관점
    - 개념 관점 : 도메인 속에 있는 개념과 개념간의 관계
    - 명세 관점 : 객체가 어떤 역할을 가지고 협력하는 가에 대한 초점
    - 구현 관점 : 객체간의 협력을 코드로 구현하는 초점
- 포함, 합성관계 : 어떤 한 객체가 다른 객체한테 속할 때 지칭하는 말
- 연관 관계 : 서로 다른 객체가 포함되지 않고 관계만 맺고 있을 때 지칭하는 말

## 실습 코드

```java
package CSstudying;

import java.util.ArrayList;
import java.util.List;

/*
커피 주문해라(커피 이름) -> 손님
메뉴 항목 찾아라(커피 이름) -> 메뉴판 -> return 메뉴항목
커피 제조해라(메뉴항목) -> 바리스타 -> return 커피
커피 생성해라(메뉴항목) -> 커피 -> return 커피
 */

public class OOPMain {
    public static void main(String[] args) {
        Menu menu = new Menu();
        Barista barista = new Barista();

        Customer customer = new Customer();
        System.out.println(customer.orderCoffee("americano", menu, barista));
    }
}

class Customer {
    public Coffee orderCoffee(String menuName, Menu menu, Barista barista) {
        MenuItem menuItem = menu.findMenuItem(menuName);
        return barista.makeCoffee(menuItem);
    }
}

class MenuItem {
    private String menuName;
    private int price;

    public MenuItem(String menuName, int price) {
        this.menuName = menuName;
        this.price = price;
    }

    public String getName() {
        return menuName;
    }

    public int getPrice() {
        return this.price;
    }
}

class Menu {
    private List<MenuItem> menuItems;

    public Menu() {
        this.menuItems = new ArrayList<>();
        this.menuItems.add(new MenuItem("americano", 1000));
        this.menuItems.add(new MenuItem("latte", 2000));
    }

    public List<MenuItem> getMenuItems() {
        return menuItems;
    }

    public MenuItem findMenuItem(String menuName) {
        for (MenuItem each : menuItems) {
            if (each.getName().equals(menuName)) return each;
        }
        return null;
    }
}

class Barista {
    public Coffee makeCoffee(MenuItem menuItem) {
        return coffee = new Coffee(menuItem);
    }
}

class Coffee {
    private String name;
    private int price;

    public Coffee(MenuItem menuItem) {
        this.name = menuItem.getName();
        this.price = menuItem.getPrice();
    }

    @Override
    public String toString() {
        return "Coffee{" +
                "name='" + name + '\'' +
                ", price=" + price +
                '}';
    }
}
```

## 부록A 추상화기법

### 키워드 정리
- 분류와 인스턴스화 : 객체 간 공통적인 속성을 통해 객체를 나누는 것. 타입이 어떻게 만들어지는 가에 대한 개념
    - 단일 분류(single) : 하나의 시점에 객체가 하나의 타입에 속하는 것
    - 다중 분류(multiple) : 하나의 시점에 객체가 여러 타입에 속하는 것.
    - 정적 분류(static) : 시간이 지나도 타입을 변경할 수 없는 것
    - 동적 분류(dynamic) : 시간의 흐름에 따라 타입이 변할 수 있는 것
- 일반화와 특수화 : 객체 간의 계층을 표현. 프로그래밍 기술 중 상속과 관련
    - 100% 법칙 : 슈퍼타입의 정의가 100% 서브타입에 적용되는 것
    - Is-a 법칙 : 서브타입은 슈퍼타입의 부분집합이어야 하는 것
    - 일반화 관계가 성립하려면 서브타입이 슈퍼타입에게 순응해야 한다.
        - 구조적 순응 : 서브타입의 속성이 슈퍼타입의 속성과 100% 일치할 때
        - 행위적 순응 : 서브타입의 행위가 슈퍼타입의 행위와 100% 일치할 때
    - 서브타이핑 : 서브타입이 슈퍼타입을 대체할 수 있는 것. 설계의 유연성 목표
    - 서브클래싱 : 서브타입이 슈퍼타입을 대체할 수 없는 것. 코드의 중복 제거 목표
-집합과 분해 : 어플리케이션을 바라볼 때 작은 부품이 모인 집합과 그 부품을 나눈 분해의 과정으로 보는 것