## 1. 개요 
JWT를 이용한 인증 방법 구현하기 위해 공부한 내용.

## 2. 개념 
암호화된 Json 형식의 토큰을 의미한다. 주로 인증에 사용한다. HMAC알고리즘이나 공개키, 비밀키를 통해 암호화가 진행된다. 

### 2.1 구조 
- Header, Payload, Signature로 구분된다. 

#### 2.1.1 Header
2가지 정보가 들어간다. 토큰의 타입과 암호화 시 사용되는 알고리즘이 전달된다. 

```
{
  "alg": "HS256",
  "typ": "JWT"
}
```

#### 2.1.2 PayLoad 
전달되는 데이터를 의미한다. JWT에서는 Claims라고 부른다. PayLoad의 종류는 public, Registered, Private으로 나눠진다. 각 종류는 추후에 살펴보자. 

```shell script
{
  "userId" : "guswns1659",
  "name": "John Doe",
}
```

#### 2.1.3 Signature
JWT에 대한 유효성을 보증하는 서명?이다. 인코딩된 header와 payload, 사용된 alogorithm이 함께 담아서 넘어온다. 

```shell script
HMACSHA256(
  base64UrlEncode(header) + "." +
  base64UrlEncode(payload),
  secret)
``` 

## 3. 어떻게 동작하는가? 
### 3.1 로그인 시 JWT 사용 과정 
- 클라이언트는 Post로 id와 password를 보낸다. 
- 서버는 id와 password 유효성을 확인하고 userId를 답은 JWT를 만든다.
- 서버는 만든 jwt를 쿠키에 담아서 전달한다.
- 이후 로그인에는 클라이언트 요청에 JWT가 담아서 온다. 
- 서버는 JWT의 signature의 유효성을 검사한다. 
	- [x] 유효성 검사가 jwt만들 때 넣었던 key인가?  
- payload 속 사용자의 ID 추출한다. 
- 이 아이디가 로그인됐다는 것을 파악한다. 

### 3.2 JWT 토큰으로 만드는 법

```java
@GetMapping("/hello")  
public String hello() {  
  String key = "A";  
  String userId = "guswns1659";  
  Map<String, Object> headers = new HashMap<>();  
  headers.put("typ", "JWT");  
  headers.put("alg", "HS256");  
  
  Map<String, Object> payloads = new HashMap<>();  
  Long expiredTime = 1000 * 60L;  
  Date now = new Date();  
  now.setTime(now.getTime() + expiredTime);  
  payloads.put("exp", now);  
  payloads.put("userId", userId);  
  
  this.jwt = Jwts.builder()  
 .setHeader(headers)  
 .setClaims(payloads)  
 .signWith(SignatureAlgorithm.HS256, key.getBytes())  
 .compact();  
  
  return this.jwt;  
}
``` 

- 결과 

```shell script
eyJ0eXAiOiJKV1QiLCJhbGciOiJIUzI1NiJ9.eyJleHAiOjE1ODY0MDg3ODQ4ODUsInVzZXJJZCI6Imd1c3duczE2NTkifQ.KoUzMWGMI-FxBqHtdNvoxLBFton_tZXtQKejRfMuitc
```

### 3.3 JWT 토큰을 Parsing하는 법 

```java
@GetMapping("jwtParsing")  
public String jwtParsing() {  
  Claims claims = Jwts.parser()  
 .setSigningKey("A".getBytes())  
 .parseClaimsJws(this.jwt)  
 .getBody();  
  return claims.get("userId", String.class);  
}
```

```shell script
guswns1659
```

## 4. Session과 차이점 
### 4.1 session
- Session에 정보가 많으면 메모리를 많이 잡아먹는다. 
- 서버에서 Session을 관리하기 때문에 세션 저장소를 유지해야 한다. 세션이 많아질수록 저장소가 많아지기 때문에 서버의 부담이 늘어간다.
### 4.2 차이점 
session은 서버에 세션 정보를 저장하지만 jwt는 브라우저가 가지고 있어서 매번 요청한다.

## 5. Jwt 관련한 자바 라이브러리, jjwt 사용법 

### 5.1 jwt 의존성 추가  

```shell script
// https://mvnrepository.com/artifact/io.jsonwebtoken/jjwt
compile group: 'io.jsonwebtoken', name: 'jjwt', version: '0.9.1'
```

### 5.2 클라이언트에서 jwt 넘어올 때 parsing 하는 법
- request

```
`http http:``//localhost``:8080``/parser``?jwt=eyJhbGciOiJIUzI1NiJ9.eyJpc3MiOiJTdG9ybXBhdGgiLCJzdWIiOiJtc2lsdmVybWFuIiwibmFtZSI6Ik1pY2FoIFNpbHZlcm1hbiIsInNjb3BlIjoiYWRtaW5zIiwiaWF0IjoxNDY2Nzk2ODIyLCJleHAiOjQ2MjI0NzA0MjJ9.kP0i_RvTAmI8mgpIkDFhRX3XthSdP-eqqFKGcU92ZIQ`
```

```
`@RequestMapping``(value =` `"/parser"``, method = GET)`

`public` `JwtResponse parser(``@RequestParam` `String jwt)` `throws` `UnsupportedEncodingException {`

`Jws<Claims> jws = Jwts.parser()`

`.setSigningKeyResolver(secretService.getSigningKeyResolver())`

`.parseClaimsJws(jwt);`

`return` `new` `JwtResponse(jws);`

`}`
```

