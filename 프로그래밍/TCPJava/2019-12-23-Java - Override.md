## 목차
- 재정의(Override)
- 상속 관계에서 객체 생성하는 2가지 방법
## 핵심
- **Override(재정의)는 항상 하위 클래스의 메서드 실행을 도와준다.**
- **상속 개념은 메모리 안에서 어떻게 작동되는 지 이해해야 한다.**

## 재정의(Override)
재정의란 상속 관계에서 하위 클래스가 상위 클래스의 기능(메서드)를 수정하는 것을 말한다. 이 기능이 필요한 이유는 부모의 메서드가 항상 자식에게 필요한 메서드가 될 수는 없기 때문이다.

## 상속 관계에서 객체 생성하는 2가지 방법
1. 자료형을 하위 클래스로 하는 법
```java
Dog d = new Dog();
d.eat();
```

위와 같은 코드에서는 인스턴스 변수 d가 가르키는 인스턴스는 Dog지만 메모리가 확장(extends)됐기 때문에 상위 클래스인 Animal 영역까지 가르킨다. 그래서 메서드를 호출하면 Override(재정의)된 하위 클래스의 메서드가 호출된다.

2. 자료형을 상위 클래스로 하는 법(upCasting)
```java
Animal d = new Dog() // 객체는 Dog지만 자료형이 Animal로 형변환된다.(upCasting)
d.eat();
```

위와 같은 코드에서는 인스턴스 변수 d가 가르키는 인스컨스 Animal이다. 그러면 d.eat()를 호출하면 Animal의 eat() 호출되어야 한다. 하지만 하위 클래스가 eat()을 Override(재정의)를 했다면 하위 클래스의 eat()이 호출된다. **재밌는 점이 인스턴스 변수 d가 가르키는 객체는 Animal뿐이라서 하위 클래스인 Dog에 갈 수 없는데 Override(재정의)가 됐다면 하위 클래스에 접근할 수 있다.** 이게 프로그램 실행될 때 정해지기 때문에 정적 바인딩이라 한다.

## Override의 강력함
Override는 강력하다. 왜냐하면 메모리에 하위, 상위 메서드가 공존할 때 Override(재정의)가 되어 있으면 무조건 하위 메서드가 실행된다. 이는 하위 클래스의 구동 방식(소스 코드)를 모르더라도 상위 클래스를 통해 하위 클래스의 기능을 실행 시킬 수 있다. ~~아까 말한 리모콘처럼~~
### 동적바인딩
Override는 동적바인딩이다. 동적바인딩은 프로그램이 실행될 때 호출되는 메서드의 주소가 결정되는 방법이다. 컴파일되는 시점에 호출되는 메서드가 정해지지 않고 프로그램이 시작하면서 호출되는 메서드가 즉석으로 결정된다. 이렇게 미리 정하지 않고 하다보니 속도가 느려지는 원인이 되기도 하지만 유용하다.

일전에 Method Overloading에 대해 배울 때 [모르면 여기로](https://guswns1659.tistory.com/41) 오버로딩은 정적 바인딩이라 말했다. 이제 둘의 차이가 확 느껴진다. 정적 바인딩은 프로그램 시작 전에 미리 호출될 메서드가 정해지는 것. 그래서 속도에 영향이 없다. 하지만 동적 바인딩은 프로그램이 시작하면서 호출될 메서드가 정해지는 것. 그래서 속도가 느릴 수 있다.
