# Programming 기초

- 프로그래밍
    - 정의: 필요한 작업들을 순서대로 나열 해야하는데 컴퓨터가 이해할 수 있도록 프로그래밍 언어로 표현하는 것
        - 

            ![Programming/Untitled.png](Programming/Untitled.png)

        - 사고능력 : 작업을 논리적인 순서에 따라 정리하는 것
        순서도 : 사고의 결과를 그림으로 표현한 것
            - ex) 배고픔 → 식당 찾기 위해 나간다 → 식당을 고른다 → 계산한다 → 음식을 먹는다 → 식사를 했다
            - 중요한 것은 작업을 논리적인 순서에 따라 요리책처럼 정리하는 사고 능력. 순서도는 다른 사람에게 설명하기 위한 도구
    - 컴퓨터적인 사고 방식
        - Input - process - output
    - 변수(Variable)
        - 변수란 값의 주소를 기억하는 것이다.
    - 조건에 따라 다른 길 가기 (IF)
        - 순서도에서 Decision이 들어간다.
    - 프로그래밍은 기능의 변경 가능성에 따라 데이터의 형태(자료구조)와 작업의 순서(알고리즘)를 끊임 없이 조정해가는 트레이드오프의 연속
- 자료구조와 알고리즘
    - 안녕, 자료구조와 알고리즘
        - 자료구조(Data structure)란 말그대로 데이터가 구성하고 있는 구조. 그런데 어떤 문제를 해결하느냐에 따라 자료구조를 변경할 필요성이 생긴다.
        ex) 무작위로 놓인 1~100까지 숫자 중 34를 찾는 방법은 하나씩 살펴야 한다.
        하지만 1~100이 순차적으로 놓여있다면 찾기가 훨씬 수월하다.
        알고리즘은 어떤 문제 해결하기 위한 순서이다. 이 순서가 기능으로 구현될 수 있다.
    - 선형배열(Llinear array)
        - 직선 모양으로 이루어진 배열
            - 배열리스트 : 데이터들이 줄지어 있는 모양.
            - 상수시간: 어떤 문제를 해결하기 위한 수학적 연산 시간이 데이터 타입(길이)에 상관없이 동일하다는 의미. O(1), O의 약자가 무엇인지? constant? 여튼,
                - 리스트.append(), 리스트.pop() 메소드 사용할 때는 리스트의 크기에 상관없이 항상 시간이 비슷하다. 리스트.pop()은 마지막 함수 pop할 때만 O(1)이고 그 외 pop하는 경우는 pop한 자리를 한칸씩 당겨야하니 시간 복잡도가 O(n)이다.
            - 선형시간 : 어떤 문제를 해결하기 위해 수학적 연산 시간이 데이터 타입(길이)에 따라 달라지는 시간. O(n) : 길이가 n인 자료구조에서 연산하는 횟수가 n번이다.
                - 리스트.insert(index, 값), del(리스트[]) 함수 사용할 때는 리스트의 크기에 따라 시간이 달라진다.
            - question) 리스트에서 값을 검색하는 연산은 리스트 길이에 따라 소요 시간이 변화가 있는지 한번 파악해봐라.
                - 십만, 백만, 천만, 억, 십억(리스트 구성이 너무 오래 걸려서 끔.) 테스트 했을 땐 0.000.... 단위로 달라져서 index는 상수시간이다 !

                        import time.time()
                        
                        n = int(input("값을 입력하세요.."))
                        mylist = [i for i in range(n)]
                        
                        ts = time.time()
                        mylist.index(12345)
                        elapsed = time.time() - ts 
                        print("elapsed time : {}".format(elapsed))


            - 
    - 정렬(sort)과 탐색(search)
        - 정렬: 배열 속 데이터를 어떤 기준으로 다시 나열하는 것.
            - 내장함수는 매개변수를 입력받고 실행되고, 메소드는 접근자를 통해 해당 자료형에 접근한다. 둘의 차이 중요. 더 나아가서, 내장함수는 return값이 있고, 메소드는 없다.
            - sorted() : 내장함수, 원래 리스트는 두고, 정렬된 새로운 리스트를 만든다.
            - sort() : 메소드, 기존 리스트를 새롭게 정렬한다. 애는 기존 리스트 데이터가 변경됨

                L = [31, 23, 45, 64, 32, 54]

                L2 = L.sort() #값을 output 하지 않음.
                print(L, L2) #L2 = none

            - 문자열 정렬은 어렵나?
                - sorted, sort() 둘다 iterable 자료형을 key라는 정렬기준으로 정렬할 수 있다고 한다. 다만, key는 리턴값이 있는 함수여야 한다고 함. 정렬기준이 있어야 하기 때문.람다가 자주 사용된다.

                        L = ['abcd', 'xyz', 'spam']
                        sorted(L, key = lambda x:len(x))
                        L.sort(key=lambda x: len(x))

                    - lambda : 익명함수라 할 수 있다. 한번만 쓰고 안 쓸 때 주로 사용하다. 기존 함수라면 3줄로 만들꺼, 1줄로 가능하니까 편하다.

                            a = lambda x , y: x+y
                            a(1,2)

                            L = [{'name' : 'john', 'scores' : 87},{'name' : 'paul', 'scores' : 98}]
                            
                            L2 = sorted(L, key = lambda x : x['scores'], reverse = True)
                            print(L2)

        - 탐색알고리즘: 배열에서 필요한 값을 찾는 과정.
            - 선형탐색(Llinear search)
                - 앞에서부터 순차적으로 탐색하는 방법. 하나하나 다 찾기 때문에 리스트의 길이에 따라 연산 시간이 달라지는 선형시간이다.
            - 이진탐색(binary search)
                - 왜 이진인가? 1번 탐색할 때마다 탐색 범위가 1/2로 줄어들기 때문이라고 함.
                - 오름차순으로 정렬된 배열에서 인덱스를 이용해서 찾으려는 값과 비교한 뒤 범위를 절반씩 줄이는 탐색인데에.. 컴퓨터 공학에서는 divide & conquer라고 하며 연산속도는 O(logn)을 따른다고 한다.
    - Recursive algorithm(재귀 알고리즘)
        - 재귀란 무엇인가? 거듭 재, 돌아갈 귀, 다시 한번 돌아간다는 의미. 자기 자신을 다시 한번 사용하는 것으로 해석 가능하다.
        - 재귀함수로 이루어진 알고리즘이다.
            - 재귀함수는 뭐냐. 하나의 함수에서 자기 자신을 호출해 작업을 수행하는 함수라고 한다.
            - 재귀함수는 왜 중요하냐 : 많은 문제들이 재귀적인 방법으로 해결이 가능하기 때문이다.
            - ex) 이진트리(binary tree) : 하나의 수를 기준으로 왼쪽은 그 수보다 작거나 같은 경우, 오른쪽은 그 수보다 큰 경우로 분류한다. (한번 연산할 때 탐색의 범위가 2가지로 나눠지고 1가지를 선택한다..!?)
        - 재귀함수는 종결조건이 매우 중요하다고 한다.

                # 자연수 1~n까지 더하는 재귀함수
                def sum(n):
                	return n + sum(n-1)
                # 이대로 함수 작동하면 계속 sum함수를 호출하기 때문에 무한 반복된다. 
                # 이래서 종결시키는 조건이 중요하다. 
                
                def sum(n):
                	if n <= 1: #만약 조건이 ~~하면 종결! 즉, 다시 재귀함수 호출하지 않는 조건 
                		return n
                	else: # 조건이 False라면 종결 no
                		return n + sum(n-1)

        - 재귀함수 와 반복함수(iterative function)
            - 재귀함수는 자기 자신을 다시 호출하는 함수, 반복함수는 while, for문 등 반복문을 활용해 반복적으로 수행하는 함수.
            - 코드의 복잡성을 빼고, 효율성만 따지만 재귀함수는 계속해서 함수를 호출하고 리턴하는 작업을 반복한다. 그래서 효율성은 떨어질 수 있다고 한다.
    - Recursive algofithm Advanced(재귀 알고리즘 응용)
        - 재귀적 알고리즘은 구현하는 건 쉽다고 한다. 하지만 효율성이 떨어진다.
            - 효율성 확인하는 코드는 아래, 이걸 python interpreter에 열기한다.

                [lec5_recursive vs iterative speed.py](Programming/lec5_recursive_vs_iterative_speed.py)

            - 
    - 알고리즘의 복잡도
        - 복잡도란 문제를 해결하는데 어느정도의 자원을 사용하는가에 대한 정도라고 한다.
            - 공간복잡도 : 문제 해결하는데 얼마만큼 메모리 공간을 사용했느냐
            - 시간복잡도 : 문제를 해결하는데 어느정도 시간이 걸렸느냐
                - 평균 시간 복잡도 : 임의의 문제가 입력될 때 평균적으로 걸리는 시간
                - 최악 시간 복잡도 (Worst case time complexivity) : 가장 문제 해결에 오래 걸리는 입력을 했을 때 걸리는 시간.

        - 점근적 표기법(asymptotic notation), Big O notation
            - 점근적이란 점점 근접해진다는 의미다. 점근적 표기법은 영어로는 asymptotic notation이라고 한다. notation은 표기법이라는 의미라 차치하고 asymptote의 의미를 알아야한다. asymptote는 점근선으로 점점 근접해지는 선이라는 뜻이다. 무엇에 근접하는지는 상황에 따라 다를 것이다. 대신 점점 근접이라는 건 2개의 선이 있다는 의미이다. 그래서 점근적 표기법이란 점점 가까워지는 선에 대한 표기법이라고 이해된다.
            - Big O notation은 점근 표기법의 하나로 어떤 함수의 증가 양상을 다른 함수와 비교하는 것을 말한다. 보통 알고리즘의 복잡도를 표현할 때 사용한다고 한다. O(logn), O(n) ....
                - 예시

                    ![Programming/Untitled%201.png](Programming/Untitled%201.png)

                - [https://ko.khanacademy.org/computing/computer-science/algorithms/asymptotic-notation/a/asymptotic-notation](https://ko.khanacademy.org/computing/computer-science/algorithms/asymptotic-notation/a/asymptotic-notation)
                - O(logn) : 입력의 크기가 n일 때, logn에 비례해서 시간소요한다고 한다.
                O(n) : 입력의 크기가 n일 때, n에 비례해서 시간소요한다고 한다.
        - 선형시간 알고리즘, 로그시간 알고리즘, 이차시간 알고리즘
            - 선형시간 알고리즘 O(n) : 입력 값 n에 따라 연산 횟수가 n번이다.
            예) 무작위로 배열된 숫자 중에서 최댓값을 찾아야할 때, 하나하나 비교해야하기 때문에 시간은 길이에 비례한다.
            - 로그시간 알고리즘 O(logn) : 연산 횟수가 입력 값 n의 로그이다. 선형시간보다 시간이 적게 소요된다.
            예) 순차적으로 배열된 숫자 중에서 특정값을 찾아야할 때 한번 연산 시 탐색 범위가 절반으로 줄어드는 이진탐색
            - 이차시간 알고리즘 O(n2) : 연산 횟수가 입력 값 n의 제곱이다. 선형시간 보다 시간이 더 소요된다.
            예) 삽입정렬: 무작위로 나열된 숫자를 정렬하는 방법인데, (n번 대소비교하고) x (n번 정렬) = n2(제곱)
        - 병합정렬(merge sort)
            - 무작위로 배열된 숫자들을 정렬하는 방법이다. 처음엔 배열을 계속 둘로 나눈다. 원소 하나만 남을 때까지 진행한다고 한다. 알고리즘의 속도는 O(logn)이다. 예) 길이가 8인 리스트를 위 방법으로 다 나누려면 3회가 필요하다. log8 = 3이기 때문에 O(logn)이다. O() 괄호 안에는 작업 횟수가 들어간다.
            원소가 하나씩 남으면 둘 씩 짝짓되, 대소비교를해서 작은 숫자가 앞으로 오게 한다. 둘 씩 짝지으면 이제 두개, 두개 씩 대소 비교하여 나열한다. 이건 길이 n에 따라 시간이 소요된다고 한다 .

                ![Programming/Untitled%202.png](Programming/Untitled%202.png)

    - 연결리스트(Linked List)
        - 추상자료형(ADT)는 추상적(abstract)에서 시작해야 할 것 같다. 추상이란 실체가 아니라 실체를 대략적으로 표현? 하는 방법이다. 그럼 추상자료형은 이 자료형이 어떻게 구현(기능)하는지 나타내지 않고 데이터의 형태와 기능만 알려주는 자료형? 이라고 우선 이해하자.
        - node : 연결리스트에서 노드가 있다. 노드는 데이터와 다음 데이터를 가르키는 링크가 있다.
        - 연결리스트의 head, tail(꼬리), # of nodes(노드의 개수)를 기록한다.
        - 연결리스트에서 head와 tail은 처음과 끝 노드(객체)이다. data는 인덱스.data로 접근해야한다. 이 개념이 확실하지 않아서 연결리스트 순회 코드 작성하는데 시간이 오래걸렸다.
    - 연결리스트(Linked LIst) 2
        - 배열리스트는 탐색이 빠르고 삽입, 삭제가 느리다. 왜냐하면 메모리 공간안에 인덱스 순서대로 data가 나열되어 있기에 인덱스만 알면 탐색이 빠르다. 그리고 append()나 pop()도 O(1)이다.
        그런데 의문점은 인강에서 연결리스트 삽입이 O(n) 시간이라고 하는데, 책에서는 O(1)이라 하는 이유는? 강의에서는 몇번째에 넣겠다는 의미라서 하나하나 탐색을 하고 넣어야해서 그런가? 책에서는 메모리 어딘가에 넣어놓고, 이전, 이후 값의 링크를 조정하면 된다고 말하는 것 같다.
        → 책에서는 삽입과 삭제를 할 때, 이전 원소의 인덱스를 알고 있다면 O(1) 걸린다고 말한다. 즉, 이전 원소의 인덱스를 모르면 하나씩 찾아야한다.
        - 인덱스를 활용한 연결리스트의 기능 구현하기
            - 순회, traverse()

                    def traverse(self):
                    	answer = []
                      curr = self.head
                      while curr:
                    	  answer.append(curr)
                        curr = curr.next
                      return answer

            - 특정 위치 노드 찾기, getAt(pos)

                    def getAt(self, pos):
                    	if pos < 1 or pos > self.nodeCount:
                    	  return None
                    
                      i = 1
                      curr = self.head
                      while i < pos:
                    	  curr = curr.next
                        i += 1
                      return curr

            - 특정 위치에 노드 삽입, insertAt(pos, newNode)

                    	def insertAt(self, pos, newNode):
                            if pos < 1 or pos > self.nodeCount + 1:
                                return False
                    
                            if pos == 1:
                                newNode.next = self.head
                                self.head = newNode
                    
                            else:
                                if pos == self.nodeCount + 1:
                                    prev = self.tail
                                else:
                                    prev = self.getAt(pos - 1)
                                newNode.next = prev.next
                                prev.next = newNode
                    
                            if pos == self.nodeCount + 1:
                                self.tail = newNode
                    
                            self.nodeCount += 1
                            return True

            - 특정 위치 노드 삭제, popAt(pos)

                    	def popAt(self, pos):
                            if pos < 1 or pos > self.nodeCount:
                                raise IndexError
                            else:
                                prev = self.getAt(pos-1)
                                curr = self.getAt(pos)
                    
                                if pos == 1:
                                    if self.nodeCount == 1:
                                        popdata = self.head.data
                                        self.head = None
                                        self.tail = None
                                    else:
                                        popdata = self.head.data
                                        self.head = self.head.next
                                else:
                                    if pos == self.nodeCount :
                                        popdata = self.tail.data
                                        prev.next = self.tail.next
                                        self.tail = prev
                                    else:
                                        popdata = curr.data
                                        prev.next = curr.next
                                        
                            self.nodeCount -= 1
                            return popdata

            - 연결리스트 합치기

                    #간략하게 코드 구현, L1, L2 있을 때, L1에 L2 합칠 때
                    # 1. L1의 tail.next = L2.head, 2. L1.tail이 L2의 tail 되어야함
                    
                    self.tail.next = L2.head
                    self.tail = L2.tail


            - 의문 : 인덱스를 찾아서 삽입 , 삭제하면 연산속도가 O(n)이다. 속도를 더 빠르게 하려면 어떻게 해야할가?
        - 특정 노드 다음에 연결리스트 삽입, 삭제 구현
            - 연결리스트는 삽입, 삭제의 속도가 빠르다는 게 강점이다. 이 강점을 살리기 위해선 인덱스로 삽입, 삭제해선 안된다. 특정 노드 다음에 바로 삽입, 삭제할 수 있다면 속도가 빨라진다.
                - 그러면 맨 앞에 노드를 삭제하거나 삽입하는 경우는??? 더미노드를(dummy node) 0번째에 넣는다.

    - 양방향연결리스트(DoubleLinkedList)
        - 양방향연결리스트란 양방향이라는 의미대로 리스트 속 노드가 이전, 이후 노드로 이동이 가능한 리스트다. head와 tail은 더미노드가 들어가있어서, 코드가 간단해진다. 이 양방향연결리스트가 삽입과 삭제에 연산속도가 O(1)인 강점을 가진다.
        - 양방향연결리스트의 순회, 특정원소 찾기, 삽입, 삭제, 합치기 메서드는 코드를 구현했으니 나중에 볼 때 참고하길. DataStructure 파일에 있다.
    - 스택 (Stack)
        - 스택이란 데이터원소(data element)가 선형으로 구성된 자료구조이라고 한다. 데이터 원소를 삽입할 때는 끝에서 밀어넣고 (push) 출력할 때는 끝에 있는 자료부터 나간다. (pop) 이런 자료구조를 LIFO라고 한다고 함.
        - 스택 언더플로우 (stack underflow), 오버플로우(overflow)
            - underflow란 어떤 기준 아래로 흐른다는 의미다. 비어있는 스택에서 자료를 pop할 때 underflow라고 한다. 컴퓨터가 처리할 수 없는 값이라는 의미?
            - overflow란 어떤 기준 위로 흐른다는 의미다. 데이터 원소가 꽉찬 스택에서 자료를 push할 때 발생하는 오류이다.
    - 스택응용 : 수식의 후위표현법
        - 중위 표기법 (Infix notation) : 단어 사이에 들어가 표기하는 법
            - 예) (A + B) * (B + C)
        - 후위 표기법 (Postfix notation) : 연산자를 피연산자들 뒤에 표기하는 법
            - 예) A B + B C + *
            먼저 나오는 연산자부터 연산한다. 사용된 연산자는 사라진다.
        - 후위표기법을 사용하면 알고리즘을 만들어 컴퓨터에게 계산을 시킬 수 있다고 한다.
    - 스택응용 : 후위 표기 수식 계산
        - 중위 표기의 값을 한번에 도출하는 함수가 아니라 중위표기를 splitTokens로 split하고 그 값을 후위 표기로 바꾸고, 바꾼 값을 연산한다. 총 3개의 함수가 구현된다. 왜그러냐면 중위표기를 한번에 계산하는 함수를 구현했을 때 코드가 복잡했다. 연산속도가 느릴 듯..
    - 큐(Queues)
        - 큐란? 대기줄을 말한다. 대기줄은 먼저 기다린 사람이 빠지는 것처럼 큐는 먼저 들어간 데이터가 먼저 나간다. 선입선출 구조이다. 스택과의 차이점이다.
        - 스택의 연산은 큐와 비슷하지만 push(), pop()은 용어가 다르다. push 는 enqueue, pop는 dequeue이다.
        - 큐의 활용
            - 데이터 생성과 처리가 비동기적으로 일어날 때라고 한다.
            - 생성과 처리가 여러곳에서 일어나는 경우라고 한다.
            - 처리한 데이터를 수정해서 다시 처리해야할 때라고 한다.
    - 환형 큐(Circular Queues)
        - 환형 큐는?
            - 환(원)모양의 큐라는 의미이다. 데이터의 길이가 정해져있다. 왜 이걸 쓰느냐? 하나의 데이터가 처리되도 뒤 데이터들을 앞당기는 연산을 하지 않기 위해서이다. 연산속도가 상수시간이 된다.
        - 주의할 점은?
            - 길이가 정해져있기 때문에 큐의 길이를 알고 있어야한다고 한다. isfull() 연산이 추가 된다.
        - 자리를 이동하지 않고 데이터를 처리하고 생성하기 위해서 인덱스와 다르게 환형큐의 앞과 뒤를 포인터로 지정한다고 한다. front, rear로 준다. 마치 연결리스트의 head와 tail의 의미
        - Q.enqueue()하면 rear 포인터가 이동하고 데이터 추가한다.(rear 포인터가 큐의 마지막 데이터를 가르키고 있었다면 다시 인덱스0의 데이터로 이동하는 코드를 구현필요성)  Q.dequeue()하면 front포인터가 환형큐 속 다음데이터로 이동하고 그 데이터 출력
        - rear, front 포인트 구할 때 연산자 %를 활용했다. 이를 잊지말자. 어떤 조건을 구하는 건 다양한 방법이 있겠지만 연산자 ( +, /, %, //) 활용할 수 있다
    - 우선순위 큐(Priority Queues)
        - 우선순위큐란?
            - 일반 큐와 다르게 원소간 우선순위가 있어 우선순위대로 dequeue되는 큐라고 한다. 일반 큐가 FIFO방식이지만 우선순위큐는 아니다.
            예) cpu 스케줄러 방식이 우선순위 큐라고 한다. 처리해야할 다양한 업무 중 우선순위를 부여해 먼저 처리한다. 우선 순위의 기준은 모르겠다.
        - 우선순위로 꺼내는 방식은 2가지가 있다고 한다. 어떤게 유리할까?
        1. enqueue할 때 우선순위를 정해서 넣는다.
        2. dequeue할 때 우선순위를 정해서 뺀다.
        1번이 유리하다. 미리 정리해서 넣어놓으면 넣을 때만 연산하면 되지만 뺄 때 우선순위를 정하려면 길이가 길수록 연산이 길어진다.
        - 우선순위 큐를 구현하는 자료형은 배열리스트와 연결리스트가 있다. 어떤 자료형이 시간복잡도가 적을까?
        연결리스트가 적다고한다. 우선순위를 정해서 삽입하면 중간에 넣어야할 때도 많다. 이 때 배열리스트는 삽입한 원소 뒤 원소들 위치를 조정해야하기에 연산속도가 늘어난다. 삭제도 마찬가지. 반면에 연결리스트는 삭제와 삽입이 빠르다.
    - 트리(Trees)
        - 트리란
            - 선형구조가 아닌 정점(node)와 간선(edge)로 이루어진 자료구조이며, 나무처럼 뿌리에서부터 갈라지는 모양이다.

        - 루트노드(root node), 리프노드(leaf node), 내부노드(internal node)
            - 나무관점에서 뿌리노드는 자료구조가 시작하는 처음 노드이다. 리프노드는 이후 간선이 없는 노드를 말한다. 내부노드는 뿌리와 리프노드 사이에 있는 노드
        - 부모노드, 자식노드
            - 부모자식관점에서는 간선으로 이어진 노드 2개를 부모자식 관계로 본다. 부모노드(parent node)는 뿌리쪽에 가까운 노드, 자식노드(leaf node)는 리프쪽에 가까운 노드이다. sibling노드는 같은 부모의 다른 자식노드를 말한다.
            조상(ancestor)은 부모노드부터 그 위 부모노드 전부를 의미. 후손(descendent)는 자식노드부터 그 아래 자식노드 전부를 의미한다.
        - 트리의 수준(level)과 높이(height, depth), 차수(degree)
            - 레벨은 한 노드를 기준으로 뿌리노드까지 이어진 간선의 개수를 의미한다. 뿌리노드는 레벨 0이다.
            - 높이, 깊이는 한 노드를 기준으로 자신을 포함해 뿌리노드까지 존재하는 노드의 개수이다. 레벨 + 1이다.
            - 차수는 자식노드의 개수이다. degree 0 은 leaf nodes이다.
        - 이진트리(binary tree)
            - 이진트리란 모든 노드의 차수가 2이하인 트리를 말한다. 한노드에서 최대로 나눠지는게 2이다.
            - 재귀적인 속성이 있어 재귀적으로 정의할 수 있다. 뿌리노드와 왼쪽서브트리와 오른쪽서브트리가 이진트리일 때와 빈트리일 때이다. 빈트리일 때가 종결조건이다.
        - 포화이진트리(full binary tree)
            - 모든 레벨에서 노드들이 채워져있는 트리를 말한다. 높이가 k이고 노드의 개수가 2의 k승 -1인 이진트리, 말그대로 꽉차있는 모습
        - 완전이진트리(complete binary tree)
            - 높이가 k일 때 k-1번째까지는 포화이진트리 모습이다. 높이 k에서 왼쪽에서부터 노드가 채워져있다면 완전이진트리라고 한다.

                ![Programming/Untitled%203.png](Programming/Untitled%203.png)

    - 이진트리(binary trees) 추상적 자료구조 구현
        - 노드 클래스
            - 기본 속성에는 노드의 데이터, 노드의 left 값, 노드의 right 값
            - 노드에 멤버메소드가 추가된다. 왜냐하면 각 노드가 다시 뿌리노트가 되기 때문이다.
                - size() : 이진트리에 있는 노드의 개수
                - depth() : 이진트리의 깊이, 높이
                - traversal() : 이진트리 순회, 다양한 방법이 존재한다.
        - 이진트리 클래스
            - 기본 속성에는 인자로 뿌리노드를 준다.
            - 기능은 뿌리노드가 있다면 실행하는데, 노드클래스의 메소드를 호출한다.
    - 이진트리(binary trees) 기능
        - size() : 재귀적 방법 이용. 뿌리노드의 왼쪽서브트리 노드 개수 + 오른쪽서브트리 노드개수 + 1

        depth() : 재귀적 방법 이용. 뿌리노드의 왼쪽서브트리와 오른쪽 서브트리 중 큰 쪽 + 1

        traversal() : 깊이 우선 순회와 넓이 우선 순회로 나눠진다.
        깊이 우선 순회도 inorder(), preorder(), postorder()로 나눠진다.
        넓이 우선 순회는 큐를 이용한다.

    - 이진트리 넓이 우선 순회(breath first traversal)
        - 이진트리의 낮은 레벨부터 방문하는 메서드이다. level 0 → level 1 → level 2 .....

        한 노드 기준으로 왼쪽 노드를 오른쪽 노드 보다 먼저 방문한다.
        같은 레벨 노드 방문하는 기준은 먼저 방문한 부모노드의 자식 노드부터 방문한다. 같은 레벨의 맨 왼쪽에 있는 노드라 생각하면 된다.

        한 노드를 방문할 때 그 노드의 자식노드를 기억?해 놓으면 방문 순서를 정할 수 있다고 한다. 이 때 사용 가능한 자료구조는 큐였다.. 먼저 들어간게 먼저 나가는 구조이기 때문인다.. 이걸 바로 생각 못했다.
- 코딩테스트 대비
    - 놓치는 개념들
        - 연산자 활용 : +, - ,%, /, //
        - 반복문의 continue와 break 적절한 사용.